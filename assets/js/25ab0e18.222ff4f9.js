"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[335],{28453:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>o});var n=i(96540);const a={},s=n.createContext(a);function r(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),n.createElement(s.Provider,{value:t},e.children)}},30412:e=>{e.exports=JSON.parse('{"permalink":"/blog/building-a-rag-system-with-postgresql-pgvector-sqlalchemy-gemma-gemini-embeddings","source":"@site/blog/2025-09-13-building-a-rag-system-with-postgrespgvector-+-gemmagemini-embeddings/index.md","title":"Building a RAG System with PostgreSQL, pgvector, SQLAlchemy, and Gemma/Gemini Embeddings","description":"In this post, we build a Retrieval-Augmented Generation (RAG) pipeline from scratch. Using synthetic data generated with Gemini, we create embeddings with both Gemini and Gemma, store them in PostgreSQL with pgvector, query them with SQLAlchemy, and visualize the embedding space interactively. Along the way, we explore semantic search beyond keywords and even showcase a multi-agent system that automates dataset generation.","date":"2025-09-13T00:00:00.000Z","tags":[{"inline":true,"label":"python","permalink":"/blog/tags/python"},{"inline":true,"label":"data-science","permalink":"/blog/tags/data-science"}],"readingTime":32.86,"hasTruncateMarker":true,"authors":[{"name":"Henry Ruiz","title":"Blog Author","url":"https://github.com/haruiz","imageURL":"https://github.com/haruiz.png","key":"haruiz","page":null}],"frontMatter":{"title":"Building a RAG System with PostgreSQL, pgvector, SQLAlchemy, and Gemma/Gemini Embeddings","slug":"building-a-rag-system-with-postgresql-pgvector-sqlalchemy-gemma-gemini-embeddings","description":"In this post, we build a Retrieval-Augmented Generation (RAG) pipeline from scratch. Using synthetic data generated with Gemini, we create embeddings with both Gemini and Gemma, store them in PostgreSQL with pgvector, query them with SQLAlchemy, and visualize the embedding space interactively. Along the way, we explore semantic search beyond keywords and even showcase a multi-agent system that automates dataset generation.","authors":["haruiz"],"tags":["python","data-science"]},"unlisted":false,"nextItem":{"title":"Accelerating Science with JAX - Simulations, Physics, and Beyond","permalink":"/blog/accelerating-science-with-jax-simulations-physics-and-beyond"}}')},68092:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>m,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>n,toc:()=>c});var n=i(30412),a=i(74848),s=i(28453);const r={title:"Building a RAG System with PostgreSQL, pgvector, SQLAlchemy, and Gemma/Gemini Embeddings",slug:"building-a-rag-system-with-postgresql-pgvector-sqlalchemy-gemma-gemini-embeddings",description:"In this post, we build a Retrieval-Augmented Generation (RAG) pipeline from scratch. Using synthetic data generated with Gemini, we create embeddings with both Gemini and Gemma, store them in PostgreSQL with pgvector, query them with SQLAlchemy, and visualize the embedding space interactively. Along the way, we explore semantic search beyond keywords and even showcase a multi-agent system that automates dataset generation.",authors:["haruiz"],tags:["python","data-science"]},o=void 0,m={authorsImageUrls:[void 0]},c=[];function g(e){return(0,a.jsx)(a.Fragment,{})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(g,{...e})}):g()}}}]);